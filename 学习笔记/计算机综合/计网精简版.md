## 计网精简版

对<https://blog.csdn.net/cdlwhm1217096231/article/details/90760282>的精简归纳

### 1、互联网组成

#### 1）边缘部分：

- 边缘部分是指**互联网上的所有主机**
- **不同主机的通信方式：**
  - 客户-服务器方式（**C/S方式**）
  - 对等连接方式（**P2P方式**）

#### 2）核心部分：

- 由大量的网络（链路）与连接网络的**路由器**构成

- 路由的主要作用是**分组交换**和**存储转发**

  - **路由的工作原理**：路由接收分组，暂存到自身存储器，检查首部，查找转发表，根据首部中目的地址，找到合适接口将分组转发给下一个路由。

- 报文传送的几种方式

  - **电路交换：** 

    使用在电话机之间的通信，过程是建立连接----通话----释放连接

    缺点：用来传输数据的时间往往不到10%，大部分通信线路资源得不到充分利用。

  - **分组交换：**

    采用**存储转发**，划分成几组分组后进行传输

    分组的构成：报文划分成更小的**等长数据段，加上首部**，构成一个分组

  - **报文交换：** 

    **整个报文**传送到相邻结点，暂存，查找转发表，转发。

#### 3）计算机网络中常见硬件设备：

- **物理层：** 

  - **中继器：** 对信号进行放大，**扩大网络的传输距离**。
  - **集线器：** 将所有节点集中在以它为中心的节点中

- **数据链路层：**

  - **二层交换机：** 

    是一种基于MAC识别，可以“学习”**MAC地址**，并把其**存放在内部地址表**中。能**完成封装转发数据包**的功能。

    将**局域网分为多个冲突域**，每个冲突域都是有**独立的宽带**，因此大大提高了局域网的带宽。

  - **网桥：** 起到**数据接收、地址过滤与数据转发**的作用，可用来实现**多个不同网络系统之间的数据交换**。

- **网络层：**

  - **三层交换机：**
  - **路由器：** 路由器用于**连接多个逻辑上分开的网络**，具有判断网络地址和选择IP路径的功能

- **传输层及以上：**

  - **网关：**

    用于两个高层协议不同的网络互连

    与网桥只是简单地传达信息不同，**网关对收到的信息要重新打包，以适应目的系统的需求**。

    ​

### 2、计算机网络体系结构

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni03ZmU1NmE2YTkxYzkzZDI5?x-oss-process=image/format,png)

#### 1）五层协议

- **应用层：**

  直接**为用户的应用进程程序提供服务**。

  应用层协议很多，如支持万维网应用的http协议，支持电子邮件的SMTP协议，支持文件传送的FTP协议等

- **运输层：**

  负责**向两个主机中进程之间的通信提供服务**

  由于一个主机可以同时运行**多个进程**，因此**运输层有复用和分用的功能**。

  **复用**就是**多个应用层进程可以同时使用下面运输层**的服务。

  **分用**就是**运输层把收到的信息分别交付给上面应用层**中的相应进程。

  运输层主要使用下面两个协议：

  - **TCP**：**面向连接的**，数据传输的**基本单位是报文段**，可靠交付
  - **UDP**：**无连接的**，数据传输的基本单位是用户**数据报** ，不能保证可靠交付

- **网络层：**

  把运输层产生的**报文段**或用户**数据报封装成分组或包**进行传送

  **TCP/IP体系中**，由于**网络层使用IP协议**，因此分组也叫作**IP数据报**。

- **数据链路层：**

  **数据链路层**将网络层交下来的**IP数据报组装成帧** ，**每一帧包括数据和必要的控制信息。**

- **物理层：**

  任务就是透明地**传送比特流0和1** ，传送的**数据单位是比特** 。

#### 2）OSI模型

- **应用层**

  应用层是OSI模型中最靠近用户的一层，负责为用户的应用程序提供网络服务 。包括为相互通信的应用程序或进程之间建立连接，进行同步建立关于错误纠正和控制同时还包含大量的应用协议，例如远程登录（talent）、简单的邮件传输协议（SMTP）、简单的网络管理协议（SNMP），超文本传输协议（HTTP）。所有能超声网络流量的程序都在应用层。

- **表示层**

  表示层负责在不同的数据格式之间进行转换操作，以实现不同的计算机系统间的信息交换。还负责数据的加密，在传输的过程中进行保护，在发送端加密，在接收端解密，使用加密秘钥来对数据进行加密和解密。

- **会话层**

  会话层的主要功能是在两个节点间建立连接、维护、释放面向用户的连接，并对会话进行管理和控制，保证会话数据可靠传输，在会话的过程中决定到底使用全双工还是使用半双工模式传输。

- **传输层**

  传输层是OSI模型中唯一负责端到端节点数据传输和控制的层，传输层是在OSI模型中起承上启下的作用，它下面的三层主要主要面向网络通信，以确保信息准确有效的传输，上面的三层树妖面向主机用户，为用户提供各种服务。 传输层为了向会话层提供可靠的端到端传输服务，也使用差错控制和流量控制等机制。4层的协议有传输控制协议（TCP），用户数据报协议（UDP），顺序包交换协议（SPX）。

- **网络层**

  负责选择最佳的路径，规划IP(Internet Protocol)地址。

- **数据链路层**

  数据帧的开始和结束，同时提供透明传输，差错校验。

- **物理层**

  是OSI模型的最底层，它面向原始的比特流的传输，同时规范了接口标准。

#### 3）TCP/IP模型

**TCP/IP模型**

- 物理层：对应OSI模型的低两层，物理层和数据链路层；常用协议：Ethernet、FDDI、令牌环
- 网络层：对应OSI模型的网络层；常用协议：IP、ARP、RAR、ICMP
- 传输层：对应OSI模型的传输层；常用协议：TCP、UDP
- 应用层：对应OSI模型的高三层，会话层、表示层、应用层；常用协议：DNS、HTTP、SMTP、POP、TELNET、FTP



**TCP/IP是个协议组**

​	TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层：

- **网络层：**IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议
- **传输层：**TCP协议与UDP协议
- **应用层：**FTP、HTTP、TELNET、SMTP、DNS等协议

### 3、各层的作用和支持的协议

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni04NTc2Zjk0ZTQzZjAxODQx?x-oss-process=image/format,png)



### 4、物理层

- 传输数据的**基本单位：比特流0和1**

#### 1）通道：

- 单向通道（**单工通道**）：**只有一个方向通信**，没有反方向交互，如**广播**
- 双向交替通信（**半双工通信**）：通信双方都可发消息，但**不能同时发送或接收**
- 双向同时通信（**全双工通信**）：通信双方**可以同时发送和接收信息**

#### 2）通道复用技术：

- **频分复用**（FDM，Frequency Division Multiplexing）：用户在**同样时间占用不同带宽资源**
- **时分复用**（TDM，Time Division Multiplexing）：所有用户在**不同时间占用同样的频带宽度**
- **波分复用**（WDM，Wavelength Division Multiplexing）：光的频分复用
- **码分复用**（CDM，Code Division Multiplexing）：不同用户使用不同的码，可以在同样时间使用同样频带通信



### 5、数据链路层 

#### 1）点对点信道

**数据单元：帧**

三个基本问题：

- **封装成帧：**把**网络层的 IP 数据报封装成帧**
- **透明传输： ** **不管数据部分什么字符，都能传输出去**；可以通过字节填充方法解决（冲突字符前加转义字符）
- **差错检测：** 广泛使用**循环冗余检测**（CRC，Cyclic Redundancy Check）
- **点对点协议**（Point-to-Point Protocol）：**用户计算机和 ISP( Internet Service Provider) 通信**时所使用的协议

#### 2）单播，组播，广播

硬件地址（物理地址、MAC 地址）

- **单播（unicast）帧**（一对一）：收到的帧的 **MAC 地址**与**本站的硬件地址相同**

- **广播（broadcast）帧**（**一对全体**）：发送给**本局域网上所有站点**的帧

- **多播（multicast）帧**（一对多）：发送给**本局域网上一部分站点**的帧

- 组播：**主机之间的通讯模式**，也就是加入了**同一个组的主机**可以**接收到此组内的所有数据**，网络中的交换机和路由器只向有需求者复制并转发其所需数据。**主机可以向路由器请求加入或退出某个组**，网络中的**路由器和交换机**有选择的**复制并传输**数据，即**只将组内数据传输给那些加入组的主机**。这样既能一次将数据传输给多个有需要（加入组）的主机，又能保证不影响其他不需要（未加入组）的主机的其他通讯。

- 广播： 是指在**IP子网内广播数据包**，所有在子网内部的主机都将收到这些数据包。广播意味着网络**向子网每一个主机都投递一份数据包**，不论这些主机是否乐于接收该数据包。所以广播的**使用范围非常小**，只在本地子网内有效，通过路由器和网络设备控制广播传输。

- **组播协议**与现在广泛使用的**单播协议**的不同之处在于，一个主机用单播协议向n个主机发送相同的数据时，**发送主机**需要分别向**n个主机**发送，共**发送n次**。一个**主机用组播协议**向**n个主机发送相同的数据**时，只要**发送1次**，其数据由网络中的路由器和交换机逐级进行复制并发送给各个接收方，这样既节省服务器资源也节省网络主干的带宽资源。

- **环回地址/广播地址**

  - **环回地址：127.0.0.1**，通常被称为本地回环地址(Loop back address)，不属于任何一个有类别地址类。它代表设备的**本地虚拟接口**，所以默认被看作是**永远不会宕掉的接口**。

    - 作用：

      a.一是**测试本机的网络配置**，能PING通127.0.0.1说明本机的**网卡和IP协议安装都没有问题**；
      b.某些SERVER/CLIENT的应用程序在运行时需调用服务器上的资源，一般要指定SERVER的IP地址，但当该程序要在同一台机器上运行而没有别的SERVER时就可以把SERVER的资源装在本机，**SERVER的IP地址设为127.0.0.1**同样也可以运行。

  - **广播地址**：是专门用于同时向网络中所有工作站进行发送的一个地址。在使用TCP/IP协议的网络中，**主机标识段host ID为全1的IP地址为广播地址**，广播的分组传送给host ID段所涉及的所有计算机。例如，对于**10.1.1.0** （255.255.255.0 ）网段，其**广播地址为10.1.1.255**（255 即为2 进制的11111111 ），当发出一个目的地址为10.1.1.255 的分组（封包）时，它将被分发给该网段上的所有计算机。

**备注：**

- 单播，广播，组播是一种**消息发送方式**，不具体属于哪一层，但一般三层（IP层）的**路由器**可以实现上述信息传送方式。有些情况下二层也可以实现，如**二层交换机**可以运行IGMP协议用于**组播组成员的加入和退出**。
- **IGMP协议是让**连接在本地局域网上的**组播路由器知道本局域网上是否有主机上的某个进程参加或退出了某个组播组**。



#### 3）MAC地址

- MAC地址(**物理地址、硬件地址**)的概念和作用
  - 概念：MAC地址就是在媒体接入层上使用的地址，也叫**物理地址、硬件地址或链路地址**，其被固化在**适配器的ROM**中。可见，MAC地址实际上就是**适配器地址**或适配器标识符。当某台计算机使用某块适配器后，适配器上的标识符就成为该计算机的MAC地址。MAC地址长度为6字节（48比特），由IEEE的注册管理结构RA进行管理分配。
  - 作用：**MAC地址是计算机的唯一标识**，在数据链路层中，交换机通过识别MAC地址进行数据包的传输。
- **ip地址与MAC地址**的区别<https://blog.csdn.net/yang_best/article/details/41643589>
  - MAC地址是计算机的**网卡物理地址**，是**Ethernet协议**使用的地址，相当于身份证号
  - ip地址是**Internet协议**使用的地址，是**服务商提供**的，相当于邮编。



### 6、网络层

#### 1）IP（重点）

​	**Internet Protocol，网际协议**。是为计算机网络相互连接进行通信而设计的协议。

- **IP地址({<网络号>,<主机号>})分类：**

  ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni1kMTdmZDVjNzIwZDA5YWM3?x-oss-process=image/format,png)

  ​

- **IP数据报格式**：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni02YzUxYzUwZWM1MjhjN2U1?x-oss-process=image/format,png)

#### 2）子网掩码

​	子网掩码（Netmask），子网掩码为何叫“掩码”？因为它能**遮掩**（同IP地址求与）**IP地址的主机号部分**，从而**得到网络号**（或网络地址）

- 是一个32位二进制的值，可以将IP地址分离出网络地址和主机地址。用来**判断 IP 所属哪个子网络**。
- **子网掩码不能单独存在它必须结合IP地址一起使用**。
- IP地址与子网掩码按位与，可以得出该**IP地址的网络号**
- IP地址与子网掩码**取反后按位与，**可以得出该**IP地址的主机号**。
- 子网掩码由1和0组成，且1和0分别连续。**子网掩码的长度也是32位。左边是网络位，用二进制数字1表示，1的数目等于网络位的长度；右边是主机位用2进制数字0表示，0的数目等于主机位的长度；这样做的目的是为了让掩码与IP地址做与运算时用0遮住原主机数，而不改变网络段的数字；而且很容易通过0的位数确定子网的主机数；**将32位IP地址与32位的子网掩码各位进制进行 ‘与’ 运算，得到的是该IP地址的网络地址。
- 方法：子网掩码可以判断两台计算机是否属于同一网段，将计算机10进制的IP地址和子网掩码转换为2进制的形式，然后进行‘与’运算，**如果网络地址是相同的，那么两台计算机就属于同一网段**；
- 子网掩码可分为**缺省子网掩码**和**自定义子网掩码**：
  - a.**缺省（默认）子网掩码**：即为划分子网，对应的网络号都是1，主机号位都是0；
    - A类网络缺省（默认）子网掩码：255.0.0.0
    - B类网络缺省（默认）子网掩码：255.255.0.0
    - C类网络缺省（默认）子网掩码：255.255.255.0
  - b.**自定义子网掩码**： 是将**一个网络划分为几个子网**，需要每一段使用不同的网络号或者子网号，实际上我们可以认为是将主机号分为两个部分：**子网号和子网主机号**。形式如下：
    - **未做子网划分**的IP地址：**网络号+主机号**
    - **做子网划分**的IP地址：**网络号+子网号+子网主机号**。也就是说，IP地址在子网划分后，以前的主机号一部分给了子网号，剩下的是子网主机号；
- 子网掩码通常有两种格式的表示方式：
  **点分十进制格式**，如：255.255.255.128
  IP地址后面加上**‘/’符号**以及1-32位的数字，其中**1-32的数字表示子网掩码中网络标识位的长度**；例如：**192.168.1.1/24的子网掩码也可以表示为255.255.255.0**


- **以一个例题为例：**<https://blog.csdn.net/aquester/article/details/82992363>

  **inet** 10.49.126.98  **netmask** 255.255.255.192  broadcast 10.49.126.127

  10.49.126.98的二进制：
  00001010.00110001.01111110.01100010

  255.255.255.192的二进制：
  11111111.11111111.11111111.11000000

  **10.49.126.98的网络地址**为与**子网掩码**255.255.255.192的“**与**”：
  00001010.00110001.01111110.01000000
  即：
  10.49.126.64

  **“10.49.126.64”即为网络地址**，该子网可有多少主机?
  “00001010.00110001.01111110.01000000”最后一个1后的0为主机部分，这里一共6个0，即2的6次方，值为64，减去网络地址和广播地址，所以可用**主机数为62个**。

#### 3）ICMP

​	Internet Control Message Protocol，**网际控制报文协议**。

- 概念：

  ​        ICMP的全称是 Internet Control Message Protocol ，它是一种**“错误侦测与回报机制**”，**不传输用户数据**，其目的就是让我们能够**检测网路的连线状况**。ICMP数据包由一个8字节长的包头，其中前四个字节是固定格式，包括8位类型字段、8位代码字段个16位校验和；后4个字节根据ICMP类型的不同而取不同的值；

  ​         Internet 控制报文协议，负责发送消息，报告错误；属于TCP/IP协议族；主要用在**主机和路由器之间，ICMP提供移动的出错报告信息**，但是他的功能是**报告问题而不是纠正问题**，他将**出错的报文返回发送方**，**纠正问题的功能由发送方完成**；发送方根据ICMP提供的错误类型来确定如何才能更好的重新发送失败的数据包；

- 作用：

  - 侦测远端主机是否存在
  - 建立及维护路由资料
  - 重导数据传送路径
  - 数据流量控制

- ICMP报文格式：

  ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni02YjUxODBhNGFlZjY0ZDVjLmpwZw?x-oss-process=image/format,png)

- 应用：

  - **PING（Packet InterNet Groper，分组网间探测）**测试两个主机之间的连通性。**Ping命令其实就是ICMP协议的工作过程**
  - **TTL**（Time To Live，生存时间）该字段指定 IP 包被路由器丢弃之前允许通过的最大网段数量。

#### 4）IGMP

​	**IGMP（Internet Group Management Protocol）的用途**，与上一层介绍的组播（组播是一种消息传送方式，还可以在IP层）有关。

- 它用来在ip主机和与其直接相邻的组播路由器之间**建立、维护组播组成员关系**。**组播路由器不需要保存所有主机的成员关系**，它只是通过IGMP协议了解每个接口连接的网段上是否存在某个组播组的组成员，而主机只需要保存自己加入了哪些组播组。简而言之，**IGMP协议是让**连接在本地局域网上的**组播路由器知道本局域网上是否有主机上的某个进程参加或退出了某个组播组**。

#### 5）内部网关协议

- **RIP**（Routing Information Protocol，路由信息协议）
- **OSPF**（Open Sortest Path First，开放最短路径优先）

#### 6）外部网关协议

- **BGP**（Border Gateway Protocol，边界网关协议）

#### 7）ARP

- **ARP**（Address Resolution Protocol，地址解析协议）**根据IP地址获取物理地址**的一个TCP/IP协议

#### 8） VPN和NAT

- **VPN**（Virtual Private Network，**虚拟专用网**）
- **NAT**（Network Address Translation，网络地址转换）

#### 9）路由器

- 路由器：

  属于网络层，是**连接因特网中的各局域网、广域网的设备**，它会根据信道的情况自动选择和设定路由，以最佳路径，按照前后顺序发送信号。连接不同的网络，所谓不同的网络就是网络地址不同；路由器工作在IP协议网络层，用于实现子网之间转发数据，**路由器一般包含多个网络接口**，包括**局域网和广域网接口**，每个**网络接口连接不同的网络**；路由器记录着每个网络端口连接的网络信息；路由器中还包含**路由表**：记录了去往不同的网络地址应该送往的端口号；

- 作用：

  **为每个数据帧寻找最佳的传输路径**，并将其有效的传送到目的站点，

- 路由表：

  保存各种**传输路径的相关数据，供路由选择时使用**；路由表中保存着子网的标志信息、网上路由器的个数和下一个路由器的名字等内容；

  - 静态路由表：

    由**系统管理员事先设定**好的路由表；

  - 动态路由表：

    路由器**根据网络系统的运行情况**动态调整的路由表；

- 工作流程：

  数据包送到路由器后，通过数据包首部的目的**主机IP地址和子网掩码**计算出**网络地址**，即目的主机所在的网络，查找当前路由器的路由表，选择端口进行转发;下一台IP路由器收到数据包后继续转发，直到目的地；**路由转发策略称为路由选择**；

- **路由器和交换机**之间的主要区别是：

  交换机发生在OSI参考模型的第二层（数据链路层），而路由器发生在第三层（网络层）。**路由器是不同网络之间相互连接的枢纽**，路由器构成了Internet的骨架；路由器具有判断网路地址，选择IP路径的功能；

#### 10） 路由表包含什么？

- **Network Destination**：目标网段；

- **Netmask**：子网掩码，用来**判断 IP 所属哪个子网络**。 IP地址与子网掩码按位与，可以得出该**IP地址的网络号**，IP地址与子网掩码**取反后按位与，**可以得出该**IP地址的主机号**。

  子网掩码为何叫“掩码”？因为它能**遮掩**（同IP地址求与）**IP地址的主机号部分**，从而**得到网络号**（或网络地址）

  **以一个例题为例：**<https://blog.csdn.net/aquester/article/details/82992363>
  **inet** 10.49.126.98  **netmask** 255.255.255.192  broadcast 10.49.126.127

  10.49.126.98的二进制：
  00001010.00110001.01111110.01100010

  255.255.255.192的二进制：
  11111111.11111111.11111111.11000000

  **10.49.126.98的网络地址**为与**子网掩码**255.255.255.192的“**与**”：
  00001010.00110001.01111110.01000000
  即：
  10.49.126.64

  **“10.49.126.64”即为网络地址**，该子网可有多少主机?
  “00001010.00110001.01111110.01000000”最后一个1后的0为主机部分，这里一共6个0，即2的6次方，值为64，减去网络地址和广播地址，所以可用**主机数为62个**。

- **Interface：**达到该目标网段的**本地路由器的出口IP**；

- **Gateway**：网关IP，**下一跳路由器的入口IP**，通常情况下，**interface和gateway是同一网段的**。

- **Metric：跳数**，该条路有**记录的质量**，一般情况下，如果有多条到达相同目的地的路由记录，路由器会**采用metric值小的那条路由**。

- 网段和子网掩码的区别<https://blog.csdn.net/aquester/article/details/82992363>

#### 11）分组转发算法流程

- 1.从**数据报的首部**提取目的主机的**IP地址D**，得出目的**网络地址N**（子网掩码和IP地址做与运算可得出网络地址）。
- 2.若**N**就是**与此路由器直接相连的某个网络地址**，则进行**直接交付**，不需要在经过其他路由器，直接把数据报交付给目的主机（这里包括把目的**IP地址**D转换为具体的**MAC地址**（**ARP协议**），把**数据报封装成MAC帧**，在发送此帧）；否则就是**间接交付**。
- 3.若**路由表中有目的地址为D的特定主机路由**，则把数据报传送给路由表中所指明的**下一跳路由器**。
- 4.若路由表中有达到网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器。
- 5.若**路由表中有一个默认路由**，则把数据报传送给路由表中所指明的**默认路由器**。
- 6.报告转发分组出错。

#### 12）MTU

​	MTU的概念，什么是路径MTU？ MTU发现机制，TraceRoute

- **MTU：**即Maximum Transmission Unit **最大传输单元**。它是指一种通信协议的某一层上面**所能通过的最大数据包大小**（以字节为单位）。
- **路径MTU：**路径MTU是指一条因特网传输路径中，从源地址到目的地址所经过的“路径”上的所有IP跳的**最大传输单元的最小值**。或者从另外一个角度来看，就是**无需进行分片处理**就能**穿过这条“路径”的最大传输单元的最大值**。
- **路径MTU的发现方法：**这是确定两个IP主机之间路径最大传输单元的技术，其目的就是**为了避免IP分片**。首先源地址将数据报的DF位置位，在**逐渐增大发送的数据报的大小**——路径上任何需要**将分组进行分片的设备都会将这种数据报丢弃并返回“数据报过大“的ICMP响应到源地址**——这样源主机就”学习“到了**无需分片就能通过这条路径**的最大的最大传输单元。
- Traceroute:用来**侦测主机到目的主机之间所经路由情况的重要工具**。原理如下：它受到目的主机的IP后，首先给目的主机**发送一个TTL=1的UDP数据包**（每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签），而经过的第一个路由器**收到**这个数据包以后，就自动把TTL减1，而**TTL变为0以后，路由器就把这个包给抛弃了**，并同时产生一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个**TTL=2**的UDP数据报给目的主机，然后**刺激第二个路由器给主机发ICMP数据报**。**如此往复直到到达目的主机**。这样，traceroute就拿到了所有的路由器ip。Traceroute提取发送 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。



### 7、传输层

#### 1）TCP

TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，其传输的单位是**报文段**。

**特征：**

- 面向连接
- 只能点对点（一对一）通信
- 可靠交互
- **全双工通信**
- 面向**字节流**

**TCP如何保证可靠传输？**

- **确认和超时重传**
- 数据合理**分片和排序**
- **流量控制**
- **拥塞控制**
- **数据校验**

**TCP报文结构**

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni1iNzU2MDk5NjJhY2QwMmM3LmpwZw?x-oss-process=image/format,png)

**TCP首部**

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni0wMGUxZjdiZTU5Y2VkMGMz?x-oss-process=image/format,png)

#### 2）UDP

UDP（User Datagram Protocol，用户数据报协议）是 OSI（Open System Interconnection 开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，其传输的单位是用户**数据报**。
特征：

- 无连接

- 尽最大努力交付

- **面向报文**

- 没有拥塞控制

- 支持**一对一、一对多、多对多**的交互通信

- 首部开销小

  ​

**UDP报文结构**

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni0zNDE0NmI0ZGU0MDc4YjUw?x-oss-process=image/format,png)

**UDP首部**

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni0yYWVlMjE0YTYzMTZiYWQx?x-oss-process=image/format,png)

#### 3）TCP与UDP的区别

- TCP面向连接、UDP是无连接的；
- TCP提供可靠的服务、也就是说，通过TCP连接传输的数据是**无差错、不丢失**、不重复且按序到达；UDP尽最大努力交付，即不保证可靠交付
- **TCP**的逻辑通信信息是**全双工的可靠信息**；**UDP**则是**不可靠信息**
- 每一条TCP连接只能是点对点的；**UDP支持一对多、多对一、多对多的交互通信**
- **TCP面向字节流**(可能会出现黏包问题)，实际上是TCP把数据看成一连串无结构的字节流；**UDP是面向报文的**(不会出现黏包问题)
- **UDP没有拥塞控制**，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如IP电话，实时视频会议等)
- TCP首部开销20字节；**UDP的首部开销小**，只有8字节

#### 4）TCP的黏包问题

- 出现黏包问题的原因：TCP 是一个基于字节流的传输服务（UDP 基于报文的），**“流” 意味着 TCP 所传输的数据是没有边界的**，所以可能会出现**两个数据包黏在一起**的情况。
- **解决方法：**
  - **发送定长包。**如果**每个消息的大小都是一样**的，那么在接收对等方只要累计接收数据，直到数据等于一个**定长的数值**就将它作为一个消息。
  - **包头加上包体长度。**包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包头长度，依据包头长度来接收包体。
  - 在数据包之间设置边界，如**添加特殊符号 \r\n 标**记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有 \r\n，则会误判为消息的边界。
  - 使用更加复杂的应用层协议

#### 5）TCP流量控制（重点）

- 概念：流量控制（flow control）就是**让发送方的发送速率不要太快**，要**让接收方来得及接收**。

- 方法：利用**可变窗口**进行流量控制

  [流量控制滑动窗口](https://blog.csdn.net/dangzhangjing97/article/details/81008836?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1)

  - **MSS:报文段**
  - **RTT：往返时间** (表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认，不包含数据传输时间,总共经历的时间)。
  - **SWND:发送窗口** (发送端向网络一次连续写入的数据量，窗口大小就是无需等待确认应答而可以继续发送数据的最大值）
  - **CWND:拥塞窗口** 指某一源端数据流在一个RTT内可以最多发送的数据包数
  - **RWND：接收窗口**

  ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni04OWQxMjI2MGExMzIwODFm?x-oss-process=image/format,png)

- **停止等待协议和滑动窗口协议**

  - **停止等待协议：**

    是**tcp保证传输可靠的重要途径**，”停止等待”就是指**发送完一个分组就停止发送，等待对方的确认**，只有对方确认过，才发送下**一个分组** 。

  - **滑动窗口协议：**

    之所以叫滑动窗口协议，是因为窗口是不断向前走的，该协议允许发送方在**停止并等待**确认前**发送多个数据分组**。由于发送方**不必每发一个分组就停下来等待确认**，因此该协议可以**加速数据的传输**，还可以**控制流量**的问题。滑动窗口协议中，允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它受限于在流水线 中为未确认的分组数不能超过某个最大允许数N。**滑动窗口协议是TCP使用的一种流量控制方法**，此协议能够加速数据的传输。 只有在**接收窗口向前滑动**时（与此同时也**发送了确认**），**发送窗口才有可能向前滑动**。收发两端的窗口按照以上规律不断地向前滑动，因此这种协议称为滑动窗口协议。当**发送窗口**和接收窗口的大小都**等于1**时，就是**停止等待协议**。

#### 6）TCP拥塞控制（重点）

- 概念：拥塞控制就是**防止过多的数据注入到网络**中，可以**使网络中的路由器或链路不致过载**。

- 解决方法：

  - 慢启动( slow-start )
  - 拥塞避免( congestion avoidance )
  - 快重传( fast retransmit )
  - 快恢复( fast recovery )

  [拥塞控制详细内容](https://blog.csdn.net/qq_43313035/article/details/89069962)

  ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni0xNjNkMTQ2MzUyZjY0NGRm?x-oss-process=image/format,png)

  ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni03MTJiY2ZiNWY4MWI4MmIw?x-oss-process=image/format,png)

  ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni05YzFjNjNlMWY5NGE2YWZm?x-oss-process=image/format,png)

- **快重传和快恢复**

  - **快重传：**

    如果发送方设置的**超时计时器时限已到但还没有收到确认**，那么很可能是**网络出现了拥塞**，致使**报文段**在网络中的某处**被丢弃**。这时，TCP马上把拥塞窗口 **cwnd 减小到1**，并执行慢开始算法，同时把**慢开始门限值ssthresh减半**。这是不使用快重传的情况。**快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认**（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。接收方收到了M1和M2后都分别发出了确认。现在假定接收方**没有收到M3但接着收到了M4**。显然，**接收方不能确认M4**，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定**，接收方应及时发送对M2的重复确认**，这样做可以**让发送方及早知道报文段M3没有到达**接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，**也还要再次发出对M2的重复确认**。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，**发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3**，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。

  - **快恢复：**

    - a.当发送方连续**收到三个重复确认**，就执行“乘法减小”算法，把慢开始**门限ssthresh减半**。这是**为了预防网络发生拥塞**。请注意：接下去**不执行慢开始算法**。
    - b.由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即**拥塞窗口cwnd现在不设置为1**），而是把**cwnd值**设置为慢开始门限ssthresh减半后的数值，然后开始**执行拥塞避免算法**（“加法增大”），使**拥塞窗口缓慢地线性增大**。

#### 7）TCP传输连接管理(重点)

[TCP三次握手和四次握手](https://blog.csdn.net/qq_38950316/article/details/81087809)

- **状态控制码**
  - ACK：确认比特（Acknowledge）。只有当 ACK＝1 时确认号字段才有效，代表这个封包为确认封包。当 ACK＝0 时，确认号无效。
  - SYN：同步比特(Synchronous)，SYN 置为 1，就表示这是一个连接请求或连接接受报文，通常带有 SYN 标志的封包表示『主动』要连接到对方的意思。
  - FIN：终止比特(Final)，用来释放一个连接。当 FIN＝1 时，表明此报文段的发送端的数据已发送完毕，并要求释放传输连接。

- **TCP建立连接：三次握手**

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni0yYzI2NzM0N2YxMTBiZjcx?x-oss-process=image/format,png)

- **TCP 建立连接全过程解释：**

  - 1.客户端发生SYN给服务器，表示客户端向服务器请求建立连接；
  - 2.服务端收到客户端的SYN，并回复SYN+ACK给客户端(同意建立连接)；
  - 3.客户端收到来自服务器的SYN+ACK后，回复ACK给服务端(表示客户端收到了服务端发的同意报文)；
  - 4.服务端收到客户端的ACK，连接已建立，可以进行数据传输。

- **建立连接的详细过程：**

  - a.B的TCP**服务器进程**首先创建**传输控制块TCB**,准备**接受客户进程的连接请求**。然后服务器进程就处于LISTEN(收听)状态，等待客户的连接请求。如有，就做出响应。
  - b.A的TCP**客户进程**也是首先**创建传输控制模块TCB**，然后向B发出连接请求**报文段**，这时首部中的同步位SYN=1，同时选择一个**初始序号seq=x**。TCP规定，SYN报文段(即SYN=1的报文段)**不能携带数据**，但是要消耗一个序号。这时，TCP**客户进程进入SYN-SENT(同步已发送)**状态。
  - c.B收到连接请求报文段后，如**同意建立连接**，则向A发送确认。在确认报文段中应把SYN和ACK位都置1，确认号是ack=x+1,同时也**为自己选择一个初始序号seq=y**。注意：这个**报文段也不能携带数据**，但同样要消耗一个序号。这时TCP服务器进程进入**SYN-RECV(同步收到)状态**。
  - d.TCP**客户进程**收到B的确认后，还要**向B给出确认**。确认报文段的ACK置1，确认号ack=y+1，而自己的序号seq=x+1。TCP标准规定，ACK报文段可以携带数据。但如果不携带数据则不消耗序号。在这种情况下，下一个数据报文段的序号仍然是seq=x+1。这时，TCP的连接已经建立，**A进入ESTABLISHED(已建立连接)状态**。当B接收到A的确认后，**B也进入ESTABLISHED(已建立连接)状态**。

- **Q1：TCP为什么要进行三次握手？**

  因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。(而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手)
  因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信
  为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误

  ​

- **TCP断开连接：四次挥手**

  ![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzQwNzE3Ni03YzNlYjAwMmExNTI3YjE0?x-oss-process=image/format,png)

- **TCP 断开连接全过程解释：**

  - 1.客户端发送 FIN 给服务器，说明**客户端不必发送数据给服务器了**（请求释放从客户端到服务器的连接）；
  - 2.服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；
  - 3.客户端收到服务端回复的 ACK，此时**从客户端到服务器的连接已释放**（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；
  - 4.服务端继续**发送之前没发完**的数据给客户端；
  - 5.服务端发送 **FIN+ACK 给客户端，说明服务端发送完了数据**（请求释放从服务端到客户端的连接，就算没收到客户端的回复，**过段时间也会自动释放**）；
  - 6.服务端收到客户端的 ACK 后，断开从服务端到客户端的连接

- **释放连接的详细过程：**

  - a.**A和B都处于ESTABLISHED状态**，A的应用进程首先向其TCP发出连接释放报文段，并**停止再发送数据，主动关闭TCP连接**。A把连接释放报文段首部的FIN置1，其序列号seq=u，它等于前面已经传送过的数据的最后一个字节的序号加1。这时，A进入**FIN-WAIT-1(终止等待1)**状态，等待B的确认。注意：TCP规定：FIN报文段即使不携带数据，它也会消耗一个序号。
  - b.B收到连接释放报文段后即发出确认，确认号是ack=u+1，而这个报文段自己的序号是v，等待B前面已经传送过的数据的最后一个字节的序号加1。然后**B就进入CLOSE-WAIT(关闭等待)状态**。TCP服务器进程这时应通知高层应用进程，因而从A到B这个方向的连接就释放了，这时的TCP连接处于**半关闭状态**，即A已经没有数据要发送了，但**B若发送数据，A仍要接收**。也就是说，从B到A这个方向的连接并没有关闭，这个连接可能会持续一段时间。
  - c.A收到来自B的确认后，就进入**FIN-WAIT-2(终止等待2)状态**，等待B发出的连接释放报文段。如果B已经没有要向A发送的数据，其应用进程就会通知TCP释放连接。这时B发出的连接释放报文段必须使FIN=1。现假定B的序号为w(在半关闭状态B可能又发送了一些数据)。B还必须重复上次已经发送过的确认号ack=u+1。这时，**B就进入LAST-ACK(最后确认状态)**，等待A的确认。
  - d.A在收到B的释放连接报文段后，必须对此发出一个确认。在确认报文段中把ACK置1，确认号ack=w+1，而自己的序号是seq=u+1(根据TCP标准，前面发送过的FIN报文段要消耗一个序号)。然后经过时**间等待计时器(TIME-WAIT)设置的时间2MSL**后，**A才进入到CLOSED状态**。时间**MSL叫做最长报文段寿命**。

- **Q2：TCP 为什么要进行四次挥手？**

  因为 TCP 是**全双工模式**，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 **ACK 和 FIN 是分开发送的**（中间隔着数据传输），而 TCP 建立连接时服务器的 **ACK 和 SYN 是一起发送**的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。

- **Q3：为什么 TCP 建立连接时可以 ACK 和 SYN 一起发送，而断开连接时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）**

  因为客户端请求释放时，**服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求**（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。

- **Q4：为什么客户端断开连接时，最后需要 TIME-WAIT 等待 2MSL 呢？**

  - 1.为了保证客户端发送的最后一个 ACK 报文能够到达服务端。**若未成功到达，则服务端超时重传 FIN+ACK 报文段**，客户端再重传 ACK，并重新计时。
  - 2.防止已失效的连接请求报文段出现在本连接中。TIME-WAIT **持续 2MSL** 可使本连接持续的时间内所产生的**所有报文段都从网络中消失**，这样可使下次连接中不会出现旧的连接报文段。

#### 8）常见面试题

- **Q：为什么连接的时候是三次握手，关闭的时候却是四次握手？**

  答：因为当Server端收到Client端的SYN连接请求报文后，可以**直接发送SYN+ACK报文**。其中**ACK报文是用来应答**的，**SYN报文是用来同步的**。但是关闭连接时，当Server端收到FIN报文时，很可能并**不会立即关闭SOCKET**，所以只能**先回复一个ACK报文**，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

- **Q：为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

  虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以**TIME_WAIT状态就是用来重发可能丢失的ACK报文**。在Client发送出最后的ACK回复，但该ACK可能丢失。**Server如果没有收到ACK，将不断重复发送FIN片段**。所以**Client不能立即关闭，它必须确认Server接收到了该ACK**。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

- **Q：为什么不能用两次握手进行连接？**

  ​	3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

         现在把三次握手改成仅需要两次握手，**死锁是可能发生的。**作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将**不知道S 是否已准备好，不知道S建立什么样的序列号**，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，**C**认为连接还未建立成功，将**忽略S发来的任何数据分组，只等待连接确认应答分组**。而**S**在发出的分组超时后，**重复发送同样的分组。这样就形成了死锁**。

- **Q：如果已经建立了连接，但是客户端突然出现故障了怎么办？**

  ​	TCP还设有一个**保活计时器**，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发**送10个探测报文仍然没反应，服务器就认为客户端出了故障**，接着就关闭连接。

### 8、应用层

#### 1） DNS

- DNS（**Domain Name System，域名系统**）是互联网的一项服务。它作为将**域名和 IP 地址相互映射**的一个**分布式数据库**，能够使人更方便地访问互联网。**DNS 使用 TCP 和 UDP 端口 53**。当前，对于每一级域名长度的限制是 63 个字符，域名总长度则不能超过 253 个字符。

- 域名 ::= **{<三级域名>.<二级域名>.<顶级域名>}**，如：blog.huihut.com

- **DNS劫持：**

  指用户访问一个被标记的地址时，DNS服务器**故意将此地址指向一个错误的IP地址的行为**。范例：网通、电信、铁通的某些用户有时候会发现自己打算访问一个地址，却被转向了各种推送广告等网站

- **DNS污染：**

  指的是用户访问一个地址，**国内的服务器**(非DNS)监控到用户访问的已经被标记地址时，**服务器伪装成DNS服务器**向用户**发回错误的地址**的行为。比如不能访问Google、YouTube等。

- **DNS查询算法**

  - **主机向本地域名服务器**的查询一般都是采用**递归查询**，即如果主机所询问的**本地域名服务器**不知道被查询域名的IP地址，那么本地域名服务器就以DNS客户的身份，向**其他根域名服务器**继续发出查询请求报文，而不是让该主机自己进行下一步的查询。 因此，**递归查询返回的查询结果或是所要查询的IP地址，或是报错**。
  - **本地域名服务器向根服务器**的查询通常采用**迭代查询**，即当根域名服务器收到本地域名服务器收到本地域名服务器发出的**迭代查询**请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器“**下一次应向哪个域名服务器进行查询**”。然后让本地域名服务器进行后续的查询。根域名服务器通常把自己知道的顶级域名服务器的IP地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的IP地址，要么告诉本地域名服务器下一步应当向哪一个权限域名服务器进行查询。本地域名服务器就这样进行迭代查询。

#### 2） FTP

- FTP（File Transfer Protocol，文件传输协议）是用于在网络上进行文件传输的一套标准协议，使用**客户/服务器模式**，**使用 TCP 数据报**，提供交互式访问，双向传输。
- TFTP（Trivial File Transfer Protocol，简单文件传输协议）一个小且易实现的文件传输协议，也使用客户-服务器方式，使用UDP数据报，只支持文件传输而不支持交互，没有列目录，不能对用户进行身份鉴定

#### 3） TELNET

- TELNET 协议是 TCP/IP 协议族中的一员，是 **Internet 远程登陆服务**的标准协议和主要方式。它**为用户提供了在本地计算机上完成远程主机工作**的能力。

#### 4） HTTP（重点）

- HTTP（HyperText Transfer Protocol，**超文本传输协议**）是用于从 WWW（World Wide Web，**万维网）服务器**传输超文本到**本地浏览器**的传送协议。

- **HTTP 是万维网的数据通信的基础**。

- **请求状态码：**

  - **1xx：**表示通知信息，如请求收到了或正在进行处理
    - **100 Continue：**继续，客户端应继续其请求
    - **101 Switching Protocols** 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到 HTTP 的新版本协议
  - **2xx**：表示成功，如接收或知道了
    - **200 OK:** 请求成功
  - **3xx：表示重定向**，如要完成请求还必须采取进一步的行动
    - 301 Moved Permanently: 永久移动。请求的资源已被永久的移动到新 URL，返回信息会包括新的 URL，浏览器会自动定向到新 URL。今后任何新的请求都应使用新的 URL 代替
  - **4xx：**表示**客户的差错**，如请求中有错误的语法或不能完成
    - **400 Bad Request**: **客户端请求的语法错误，服务器无法理解**
    - 401 Unauthorized: 请求**要求用户的身份认证**。
    - 403 Forbidden: 服务器理解请求客户端的请求，但是**拒绝执行此请求**（权限不够）
    - 404 Not Found: 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置 “您所请求的**资源无法找到**” 的个性页面
    - 408 Request Timeout: 服务器等待客户端发送的请求时间过长，超时
  - **5xx：表示服务器的差错**，如服务器失效无法完成请求
    - 500 Internal Server Error: 服务器内部错误，无法完成请求
    - 503 Service Unavailable: 由于**超载或系统维护**，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的 Retry-After 头信息中。
    - 504 Gateway Timeout: 充当网关或代理的服务器，未及时从远端服务器获取请求

- **HTTP请求报文与响应报文格式**

  **请求报文包含三部分：**

  - **请求行：**包含**请求方法、URI、HTTP版本**信息
  - 请求首部字段
  - 请求内容实体

  **响应报文包含三部分：**

  - **状态行：**包含**HTTP版本、状态码**、状态码的原因短语。
  - 响应首部字段
  - 响应内容实体

  **常见HTTP首部字段**

  - **通用首部字段**（请求报文与响应报文都会使用的首部字段）
    - Date：创建报文时间
    - Connection：连接的管理
    - Cache-Control：缓存的控制
    - Transfer-Encoding：报文主体的传输编码方式
    - 请求首部字段（请求报文会使用的首部字段）
    - Host：请求资源所在服务器
    - Accept：可处理的媒体类型
    - Accept-Charset：可接收的字符集
    - Accept-Encoding：可接受的内容编码
    - Accept-Language：可接受的自然语言
      响应首部字段（响应报文会使用的首部字段）
    - Accept-Ranges：可接受的字节范围
    - Location：令客户端重新定向到的
    - URI Server：HTTP服务器的安装信息
      实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）
    - Allow：资源可支持的HTTP方法
    - Content-Type：实体主类的类型
    - Content-Encoding：实体主体适用的编码方式
    - Content-Language：实体主体的自然语言
    - Content-Length：实体主体的的字节数
    - Content-Range：实体主体的位置范围，一般用于发出部分请求时使用


- **常用的HTTP方法有哪些？**

  - GET：用于**请求访问**已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。
  - POST：用于**传输信息**给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
  - PUT：**传输文件，报文主体中包含文件内容**，保存到对应URI位置。
  - HEAD：获得**报文首部**，与GET方法类似，只是**不返回报文主体**，**一般用于验证URI是否有效**。
  - DELETE：**删除文件**，与PUT方法相反，删除对应URI位置的文件。
  - OPTIONS：查询相应URI支持的HTTP方法。

- **GET方法与POST方法的区别**

  - get重点在从服务器上获取资源，post重点在向服务器发送数据；
  - get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用"?“连接，多个请求数据间用”&"连接，如http://127.0.0.1/Test/login.action?name=admin&password=admin，这个过程**用户是可见**的；
  - post传输数据通过**Http的post机制**，**将字段与对应值封存在请求实体**中发送给服务器，这个过程对**用户是不可见**的；
  - get**传输的数据量小**，因为受URL长度限制，但效率较高；Post可以**传输大量数据**，所以上传文件时只能用Post方式；
  - **get是不安全**的，因为URL是可见的，可能会泄露私密信息，如密码等；post较get安全性较高；
  - get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。**post支持标准字符集**，可以正确传递中文字符。

- **HTTP的缺点与HTTPS**

  - 通信使用**明文不加密，内容可能被窃听**
  - **不验证通信方身份**，可能遭到伪装
  - **无法验证报文完整性**，可能被篡改
  - HTTPS就是HTTP加上加密处理（一般是**SSL安全通信线路**）+认证+完整性保护

- **Http2.0和Http1.0区别**

  - Http2.0采用**二进制格式非文本格式**；
  - Http2.0是**完全多路复用**的，**非有序并阻塞**的只需要一个连接即可实现并行；
  - **使用报头压缩，降低了开销**；
  - Http2.0让服务器可以将响应**主动推送**到**客户端缓存**中。

#### 5） SMTP

- SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。它是在 Internet 传输 Email 的标准，是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过 **Telnet 程序来测试一个 SMTP 服务器**，**SMTP 使用 TCP 端口 25**。

#### 6） DHCP

- DHCP（Dynamic Host Configuration Protocol，**动态主机设置协议**）是一个**局域网的网络协议**，使用 **UDP 协议工作**，主要有两个用途：
  - 用于内部网络或**网络服务供应商自动分配 IP 地址**给用户
  - 用于内部**网络管理员**作为**对所有电脑作中央管理**的手段

#### 7） SNMP

- SNMP（Simple Network Management Protocol，简单网络管理协议）构成了互联网工程工作小组（IETF，Internet Engineering Task Force）定义的 Internet 协议族的一部分。该协议能够**支持网络管理系统**，用以**监测连接到网络上的设备是否有任何引起管理上关注的情况**。

### 9、相关概念

#### 1）Socket

- Socket **（套接字）**建立网络通信连接**至少要一对端口号**（Socket）。**Socket 本质**是编程接口（API），对 **TCP/IP 的封装**，TCP/IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。

#### 2） WWW

- WWW（World Wide Web，环球信息网，万维网）是一个由许多互相链接的超文本组成的系统，通过互联网访问

#### 3） URL

- 概念：**URL（Uniform Resource Locator，统一资源定位符）**是因特网上标准的资源的地址（Address）

- 标准格式：协议类型:[//服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID]

- 完整格式：协议类型:[//[访问资源需要的凭证信息@]服务器地址[:端口号]][/资源层级UNIX文件路径]文件名[?查询][#片段ID] 注意：其中[访问凭证信息@；:端口号；?查询；#片段ID]都属于选填项,可以省略，如：https://github.com/cdlwhm1217096231

- **URL与URI的区别：**

  <https://blog.csdn.net/qq_32595453/article/details/80563142>

  URI（统一资源标识符）和URL可能是相同的概念，其实并不是，URI和URL都定义了资源是什么，但URL还定义了该如何访问资源。**URL是一种具体的URI，它是URI的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息**。URI 是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，是绝对的。

### 10. 一个链接的处理流程

当你输入一个网址/点击一个链接，发生了什么？（以www.baidu.com为例）

- **1.点击网址后，应用层的DNS协议会将网址解析为IP地址；**

  DNS查找过程：浏览器会**检查缓存中有没有**这个域名对应的解析过的**IP地址**，如果缓存中有，这个解析过程就将结束。如果用户的浏览器缓存中没有，浏览器会查找**操作系统缓存（hosts文件）**中是否有这个域名对应的DNS解析结果。若还没有，此时会**发送一个数据包给DNS服务器**，DNS服务器找到后将解析所得IP地址返回给用户。

- **2.在应用层，浏览器会给web服务器发送一个HTTP请求；**

  请求头为：GET http://www.baidu.com/HTTP/1.1

- **3.在传输层，（上层的传输数据流分段）HTTP数据包会嵌入在TCP报文段中；**

  TCP报文段需要设置端口，接收方（百度）的HTTP端口默认是80，本机的端口是一个1024-65535之间的随机整数，这里假设为1025，这样**TCP报文段**由**TCP首部**（包含发送方和接收方的**端口信息**）+ **HTTP数据包组**。

- **4.在网络层中，TCP报文段再嵌入IP数据包中；**

  IP数据包需要知道双方的IP地址，本机IP地址假定为192.168.1.5，接受方IP地址为220.181.111.147（百度），这样**IP数据包**由**IP头部（IP地址信息）**+**TCP报文段**组成。

- **5.在网络接口层，IP数据包嵌入到数据帧（以太网数据包）中在网络上传送；**

  数据帧中包含**源MAC地址**和**目的MAC地址**（通过ARP地址解析协议得到的）。这样**数据帧**由**头部（MAC地址）**+**IP数据包**组成。

- **6.数据包经过多个网关的转发到达百度服务器，请求对应端口的服务；**

  服务接收到发送过来的以太网数据包开始解析请求信息，从**以太网数据包**中**提取IP数据包**—>**TCP报文段**—>**HTTP数据包**，并组装为有效数据交与对应线程池中分配的线程进行处理，在这个过程中，**生成相应request、response**。

- **7.请求处理完成之后，服务器发回一个HTTP响应；**

  请求处理程序会阅读请求及它的**参数和cookies**。它会读取也可能更新一些数据，并将数据存储在服务器上。处理完毕后，数据通过**response对象给客户输出信息**，输出信息也需要**拼接HTTP协议头部分**，关闭后断开连接。断开后，服务器端**自动注销request**、**response对象**，并将释放对应线程的使用标识（一般一个请求单独由一个线程处理，部分特殊情况有一个线程处理多个请求的情况）。响应头为：HTTP/1.1 200 OK

- **8.浏览器以同样的过程读取到HTTP响应的内容（HTTP响应数据包），然后浏览器对接收到的HTML页面进行解析，把网页显示出来呈现给用户。**

  客户端接收到返回数据，去掉对应头信息，形成也可以被浏览器认识的页面HTML字符串信息，交与浏览器翻译为对应页面规则信息展示为页面内容。


### 参考文档

1、https://blog.csdn.net/cdlwhm1217096231/article/details/90760282